/**	A package registry server.	Copyright: Â© 2012 Matthias Dondorff	License: Subject to the terms of the MIT license, as written in the included LICENSE.txt file.	Authors: Matthias Dondorff*/module vibe.vpm.registry;import std.file;import std.exception;import std.conv;import vibe.core.file;import vibe.http.fileserver;import vibe.http.client;import vibe.http.router;import vibe.vpm.packagesupplier;import vibe.vpm.dependency;import vibe.core.log;import vibe.inet.url;import vibe.inet.urltransfer;import vibe.data.json;/// Settings to configure the package registry.class VpmRegistrySettings {	/// Prefix used to acces the registry.	Path pathPrefix;	/// location for the package.json files on the filesystem.	Path metadataPath;}private const string PackagesPath = "packages";class VpmRegistry {	private {		Path m_path;	}	this(Path path)	{		m_path = path;	}	@property string[] availablePackages()	{		string[] all;		foreach(DirEntry de; dirEntries(m_path.toString(), SpanMode.shallow)) {			if(de.name.length <= 5 || de.name[$-5..$] != ".json") continue;			all ~= to!string(Path(de.name).head)[0..$-5];		}		return all;	}	Json getPackageInfo(string packname)	{		string ppath = (m_path~PathEntry(packname~".json")).toString();		if( !exists(ppath) )			return Json(null);		auto data = cast(string)openFile(ppath).readAll();		return parseJson(data);	}}// TODO:// manage registered packages/// adds the vpm registry to the router/// Supports (relative to pathPrefix)/// 	GET <PackagesPath>/<PackageId>.json -> corresponding package.json/// 	GET available -> lists all availablevoid registerVpmRegistry(UrlRouter router, VpmRegistrySettings settings) {	auto reg = new VpmRegistry(settings.metadataPath);	// Serving of metadata (combined package.json's)	auto metadataPrefix = settings.pathPrefix~PackagesPath;	logTrace("matching %s", metadataPrefix~"*");	logWarn("Statically serving %s, all files in this folder will be publicly accessible.", settings.metadataPath);	router.get( to!string(metadataPrefix~"*"), 		serveStaticFiles(to!string(settings.metadataPath), 			new HttpFileServerSettings(to!string(metadataPrefix))) );	// Serve available packages as a list	void avl(HttpServerRequest req, HttpServerResponse res) {		auto all = reg.availablePackages;		res.writeJsonBody(all);	}	router.get( to!string(settings.pathPrefix~"available"), &avl);	}/// Client PackageSupplier using the registry available via registerVpmRegistryclass RegistryPS : PackageSupplier {	this(Url registry) { m_registryUrl = registry; }		void storePackage(const Path path, const string packageId, const Dependency dep) {		Json best = bestPackage(packageId, dep);		logDebug("Found dllinkg: '%s'", best["url"]);		download(cast(string) best["url"], to!string(path));	}		Json packageJson(const string packageId, const Dependency dep) {		return bestPackage(packageId, dep);	}		private {		Url m_registryUrl;		Json[string] m_allMetadata;	}		private Json metadata(const string packageId) {		if( auto json = packageId in m_allMetadata ) 			return *json;				logTrace("Downloading metadata for %s", packageId);		logTrace("Connecting to %s", m_registryUrl.host);		auto client = new HttpClient;		bool ssl = m_registryUrl.schema == "https";		ushort port = m_registryUrl.port != 0? m_registryUrl.port : ssl? 443 : 80;		client.connect(m_registryUrl.host, port, ssl);		auto res = client.request((req) {				req.url = to!string(m_registryUrl.path ~ (PackagesPath ~ "/" ~ packageId ~ ".json"));				logTrace("Requested '%s'", req.url);			});				if(res.statusCode == 404) {			logError("Could not get metadata for %s", packageId);			throw new Exception("Could not get metadata for " ~ packageId);		}				string jsonData = cast(string)res.bodyReader.readAll();		Json json = parseJson(jsonData);		m_allMetadata[packageId] = json;		return json;	}		private Json bestPackage(const string packageId, const Dependency dep) {		Json md = metadata(packageId);		Json best = null;		foreach(json; md["versions"]) {			auto cur = Version(cast(string)json["version"]);			if(dep.matches(cur) && (best == null || Version(cast(string)best["version"]) < cur))				best = json;		}		enforce(best != null);		return best;	}}